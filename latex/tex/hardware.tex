\subsection{Objetivos}
Las metas principales a la hora de diseñar el teclado han sido el usar la menor cantidad de pines posible para las tareas ``básicas'' y el exponer todos los pines restantes así como varias tomas de alimentación. \newline
De esta forma, el teclado puede servir como placa de pruebas donde desarrollar drivers para otro hardware y además es modular, ya que nos permite añadir más periféricos (por ejemplo, para sonido) en el futuro sin necesidad de tener que fabricar una nueva PCB.

\subsection{Distribución}
He optado por una disposición ortolineal, split y (por ahora) QWERTY, reduciendo un par de columnas en el lateral derecho respecto al tamaño habitual, ya que varias de esas teclas raramente se usan, y al tener una forma simétrica es más sencillo de diseñar. 

\image{layout}{\textwidth}{Diseño aproximado del teclado}


\subsection{Desarrollo}
    \subsubsection{Teclas}
    Como ya vimos en la sección\ref{sec:scanning}, el escaneo de teclas se hará mediante registros de desplazamiento de entrada en paralelo y salida en serie, para un mekor tiempo de respuesta vamos a usar   componentes SPI en vez de I2C (protocolo más rápido). 
    Podríamos haber usado SN74HC165 que son algo más baratos y fáciles de encontrar, pero vamos a usar SN74HC589ADR2G ya que tienen el mismo funcionamiento pero presentan 7 de las 8 entradas en el mismo  lateral del circuito integrado (en vez de 4 en cada lado), por lo que son mucho más sencillos de enrutar.
    Además, aunque cada mitad del teclado tiene un total de 29 teclas y, por tanto, 4 registros (32 entradas) nos hubieran bastado; vamos a usar un registro por cada fila (5), ya que evitamos tener que   enrutar una de las teclas hacía el otro lado del registro y tener algunas conexiones ``saltando'' de una fila a otra. \par
    
    Realizamos las conexiones de la siguiente manera:
    \begin{itemize}
        \item Las entradas que no usamos las conectaremos a tierra para que se lean como `0'. Las teclas se conectan a VCC y (mediante ``pulldown'') a una entrada. De esta forma leeremos `1' cuando estén     pulsadas y `0' cuando no lo estén 
        \item La salida serie de cada integrado se conecta a la entrada serie del siguiente. El último se conecta a MISO(entrada SPI del microcontrolador)
        \item Las señales CS, Latch y CLK son comunes a todos los integrados
        \item Como la señal Latch resulta ser la inversa de CS, en vez de usar otro pin, invertimos el voltaje con un MOSFET
    \end{itemize}
    
    \image{inverter}{.3\textwidth}{MOSFET como inversor}
    \image{piso}{.8\textwidth}{SN74HC589ADR2G para una fila}


    \subsubsection{Cableado de las pantallas}
    Vamos a usar una pantalla en el lado izquierdo (IL91874) y dos en el derecho (ILI9163 e ILI9341), estos dispositivos necesitan de conexión SPI así como pines extra (DC, CS, RST) para ser controlados. Dado que las vamos a conectar al mismo bus, solo necesitamos 3 pines para SPI y puesto que no podemos mandar información a dos pantallas simultáneamente, también pueden usar una línea DC común. \newline
    Sin embargo las señales de DC y RST deben ser individuales y además la ILI9341 necesita dos señales DC, una para la pantalla y otra para el sensor táctil. Por tanto, también usaremos registros de desplazamiento, en este caso de entrada serie con salidas en paralelo (SN74HC595) y dichas salidas se conectaran a las entradas de control de las pantallas. \newline
    Como ya teníamos un bus SPI configurado, usar estos registros tan solo supone el uso de otro pin (CS). Sin embargo, como necesitamos cambiar estas señales mientras estamos hablando con las pantallas, no podemos tener las dos cosas en el mismo bus, por lo que usaremos un bus para los registros (escanear teclas y señales de control) y otro bus para las pantallas. Lo mas importante de este diseño es que encadenando suficientes registros podríamos controlar tantas señales de control para diversos dispositivos como queramos, manteniendo mínima la utilización de pines del MCU. 

