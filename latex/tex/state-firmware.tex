\subsection{Funcionalidad}
La mejor parte de usar una librería tan extendida como lo es QMK es que tenemos muchas facilidades a la hora de escribir el codigo ya que buena parte del trabajo está hecho ya. Esto incluye
\begin{itemize}
    \item Gestión sobre USB para reportar distintos endpoints (teclado, ratón, multimedia)
    \item Drivers para diversos periféricos tales como las pantallas ya comentadas, piezoelectricos para tener feedback sonoro o solenoides para vibración al pulsar las teclas, por nombrar algunos...
    \item Abstracciones para poder usar la misma API en diversos microcontroladores que internamente utilizan código y hardware muy diferente
    \item Documentación extensa y detallada
    \item Servidor ofcial en Discord donde podemos encontrar ayuda
\end{itemize}

\subsection{Escaneo de teclas}
Como se ha comentado en el apartado anterior, vamos a usar registros de desplazamiento, sin embargo QMK tiene soporte para cableado directo, en matrices y usando algunos otros circuitos, como \textit{IO expanders}. Sin embargo este no es el caso para los registros por lo que tendemos que escribir un poco de código para leer su información.

\subsection{Pantallas}
QMK tiene una API estandarizada (Quantum Painter\cite{qp}) para primitivas de dibujo en interfaces gráficas. Aún es ``joven'' y no soporta demasiadas pantallas, pero hace gran parte del trabajo por nosotros.

\subsection{Pantalla táctil}
QMK también tiene una capa de abstracción\cite{pointing} para diversos sensores que permiten mover el cursor, sin embargo todos se basan en medir desplazamientos y no una coordenada como es el caso de la pantalla táctil, por tanto en este caso nos vemos obligados a diseñar una arquitectura de software nueva, para poder trabajar con este otro tipo de datos de entrada.
