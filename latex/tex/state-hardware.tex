\subsection{Cableado de las teclas}\label{sec:scanning}
    \subsubsection{Conexión directa}
    La opción más sencilla que se nos puede ocurrir para conectar diversos interruptores a nuestro microcontrolador es soldarlos directamente a los pines de entrada/salida(GPIO). Para hacer esto tenemos 2 opciones:
    \begin{figure}[H]
        \begin{subfigure}[b]{.5\textwidth}
          \centering
          \includegraphics[width=.5\textwidth]{images/pull\_down}
          \caption{Pulsador con resistencia Pull-Down}
        \end{subfigure} 
        \hfill
        \begin{subfigure}[b]{.5\textwidth}
          \centering
          \includegraphics[width=.5\textwidth]{images/pull\_up}
          \caption{Pulsador con resistencia Pull-Up}
        \end{subfigure}
        \caption{Cableado directo}
      \end{figure}
    
    Si hacemos esto, sin embargo, tendremos un problema pronto porque necesitaremos un chip con muchos pines de entrada/salida, o hacer un teclado con pocas teclas porque la cantidad de GPIOs es reducida.

    \subsubsection{Matriz}
    Para solventar este problema, podemos cablear los botones mediante una matriz, usando un pin para cada fila y columna de teclas. Usamos una dimensión como salida y otra como entrada, haciendo un bucle que aplique voltaje en cada una de las filas y compruebe si las columnas reciben una entrada (tecla pulsada cerrando el circuito). \emph{Nota: También se podría iterar en la otra dimensión}
    \image{matrix}{.2\textwidth}{Cableado en matriz}

    Este diseño también tiene sus problemas, el más notorio es el conocido como ``efecto \textit{ghosting}'' en el que podemos detectar como pulsada una tecla que no lo está.
    \image{ghosting}{.2\textwidth}{Ghosting en una matriz}

    En este ejemplo, la tecla \textbf{(1, 1)} se detecta como pulsada de manera correcta pero, al pulsar también las teclas \textbf{(0, 1)} y \textbf{(0, 0)}, estamos cerrando el circuito y generando que en la columna 1 llegue voltaje a la entrada, que será interpretado como que la tecla \textbf{(1, 0)} ha sido pulsada puesto que estamos en la iteración de la fila 0.\vspace{0.2cm}\par

    Este problema se solventa de forma sencilla, añadiendo unos diodos que bloqueen esta retroalimentación permitiendo detectar \textbf{(1, 1)} pero sin la pulsación falsa de \textbf{(1, 0)} del caso anterior.
    \image{anti\_ghosting}{.3\textwidth}{Matriz anti-ghosting}

    Aunque no es muy grave, para matrices muy desiguales, por ejemplo 5x20 teclas, no estamos usando eficazmente los pines, ya que para esas 100 teclas estamos empleando 25 pines mientras que una configuración 10x10(20 pines) sería suficiente. \newline
    En este caso, podriamos hacer una distribución de teclas en forma rectangular, pero luego cablearlas como dicha matrix cuadrada, sin embargo el diseño sería bastante más confuso. \par

    Por último hay que tener en cuenta que, aunque el uso de los pines sea más óptimo, seguimos necesitando una cantidad de pines cada vez mayor conforme queramos añadir más teclas, aunque esto no debería ser un factor limitante en la mayoría de casos ya que este límite seguiría permitiendo una cantidad bastante elevada de teclas.

    \subsubsection{Lectura en serie}
    La opción que vamos a usar, inspirada en el \textit{ghoul}\cite{ghoul}, consiste en el uso de registros de desplazamiento conectados en una \textit{daisy chain}, de esta forma vamos a emplear un único pin para leer todas las teclas en una señal serie, y otros pocos pines (unos 3 o 4) para controlar estos chips mediante SPI\cite{spi} o I2C\cite{i2c}. De esta forma, podemos escanear potencialmente cualquier cantidad de teclas sin aumentar el números de pines necesarios, simplemente añadimos más registros a la cadena (aunque el escaneo se iría haciendo más y más lento)

\subsection{Pantallas}
En los últimos años es cada vez más común ver teclados que incorporan pequeñas pantallas, sin embargo, no son muy útiles ya que en la gran mayoría de casos se trata de SH1106 o SSD1306, que son dispositivos OLED de 2 colores y con una resolución bastante reducida, de 128x32 o 128x64 píxeles, en torno a la pulgada de diagonal. En nuestro teclado vamos a usar pantallas más potentes para poder mostrar información útil en vez de pequeños dibujos en estas pantallas más comunes.

\subsection{Sensor táctil}
También es relativamente común encontrar diseños que incluyen diferentes sensores (por ejemplo joysticks analógicos o PMW3360) para mover el sensor por la pantalla del ordenador sin tener que mover la mano hasta el ratón. Tal como podemos ver en el dactyl (\ref{img:dactyl}) \par 
En nuestro caso, puesto que vamos a añadir una pantalla, podemos aprovechar y usar una táctil, de forma que nos sirva para mover el cursor pero tambíen para tener una pequeña interfaz de usuario en el teclado.